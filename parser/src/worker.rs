use futures::{future, prelude::*};
use parser::custom_format::load_data_sorted;
use parser::rpc_service::{Search, PORT};
use parser::transaction::{Block, BlockHash, InputOutputPair, Transaction, TxHash};
use std::fmt::Debug;
use std::net::{IpAddr, Ipv4Addr, SocketAddr};
use std::sync::Arc;
use tarpc::tokio_serde::formats::Bincode;
use tarpc::{
    context::Context,
    server::{self, incoming::Incoming, Channel},
};

#[derive(Clone)]
struct SearchWorker {
    addr: SocketAddr,

    txs: Arc<Vec<Transaction>>,
    blocks: Arc<Vec<Block>>,
    iopairs_sorted_src: Arc<Vec<InputOutputPair>>,
    iopairs_sorted_dest: Arc<Vec<InputOutputPair>>,
}

impl SearchWorker {
    fn new(addr: SocketAddr) -> SearchWorker {
        let (txs, blocks, iopairs_sorted_src, iopairs_sorted_dest) = load_data_sorted();

        SearchWorker {
            addr,
            txs,
            blocks,
            iopairs_sorted_src,
            iopairs_sorted_dest,
        }
    }
}

#[tarpc::server]
impl Search for SearchWorker {
    async fn transactions_by_sources(
        self,
        _: Context,
        targets: Vec<TxHash>,
    ) -> Vec<InputOutputPair> {
        let mut result: Vec<InputOutputPair> = Vec::new();

        for t in targets.into_iter() {
            find_elements_in_sorted_vec(
                &self.iopairs_sorted_src,
                |x| x.source.src_tx,
                t,
                &mut result,
            );
        }

        result.sort_unstable_by_key(|k| k.source.src_tx);
        result.dedup_by_key(|k| k.source.src_tx);

        result
    }

    async fn transactions_by_destinations(
        self,
        _: Context,
        targets: Vec<TxHash>,
    ) -> Vec<InputOutputPair> {
        let mut result: Vec<InputOutputPair> = Vec::new();

        for t in targets.into_iter() {
            find_elements_in_sorted_vec(
                &self.iopairs_sorted_dest,
                |x| x.dest.unwrap().dest_tx, // safe here because iopairs_sorted_dest should not contain any pairs with None destinations!
                t,
                &mut result,
            );
        }

        result.sort_unstable_by_key(|k| k.dest.unwrap().dest_tx);
        result.dedup_by_key(|k| k.dest.unwrap().dest_tx);

        result
    }

    async fn get_transactions(self, _: Context, targets: Vec<TxHash>) -> Vec<Transaction> {
        let mut result: Vec<Transaction> = Vec::new();

        for t in targets.into_iter() {
            find_elements_in_sorted_vec(&self.txs, |x| x.id, t, &mut result);
        }

        result.sort_unstable_by_key(|k| k.id);
        result.dedup_by_key(|k| k.id);

        result
    }

    async fn get_blocks(self, _: Context, targets: Vec<BlockHash>) -> Vec<Block> {
        let mut result: Vec<Block> = Vec::new();

        for t in targets.into_iter() {
            find_elements_in_sorted_vec(&self.blocks, |x| x.id, t, &mut result);
        }

        result.sort_unstable_by_key(|k| k.id);
        result.dedup_by_key(|k| k.id);

        result
    }
}

// This function finds the elements `x` in `v` that match `F(x) == y` and appends them to
// `collector`. Note that `v` must be pre-sorted in such a way that all the elements that match
// `F(x) == y` must be consecutive, and all of the elements that match `F(x) < y` must be before
// the elements that match `F(x) == y`.
fn find_elements_in_sorted_vec<T: Copy, F, Y: Ord + Debug>(
    v: &Vec<T>,
    f: F,
    y: Y,
    collector: &mut Vec<T>,
) -> ()
where
    F: Fn(&T) -> Y,
{
    let start_index = v.partition_point(|x| f(x) < y);
    let end_index = v.partition_point(|x| f(x) <= y);

    for i in start_index..end_index {
        collector.push(v[i])
    }
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // TODO: take in a command-line arg or something:
    let server_addr = (IpAddr::V4(Ipv4Addr::LOCALHOST), PORT);

    println!("loading data...");
    let _ = load_data_sorted();
    println!("data loaded...");

    let mut listener = tarpc::serde_transport::tcp::listen(&server_addr, Bincode::default).await?;
    println!("listener listening!");

    listener.config_mut().max_frame_length(usize::MAX);
    listener
        // Ignore accept errors.
        .filter_map(|r| future::ready(r.ok()))
        .map(server::BaseChannel::with_defaults)
        // Limit channels to 1 per IP.
        .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
        // serve is generated by the service attribute. It takes as input any type implementing
        // the generated World trait.
        .map(|channel| {
            let server = SearchWorker::new(channel.transport().peer_addr().unwrap());
            println!("blahhh");
            channel.execute(server.serve())
        })
        // Max 10 channels.
        .buffer_unordered(10)
        .for_each(|_| async {})
        .await;

    Ok(())
}
